'use strict';
'use babel';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNodePrefixPath = getNodePrefixPath;
exports.findESLintDirectory = findESLintDirectory;
exports.getESLintFromDirectory = getESLintFromDirectory;
exports.refreshModulesPath = refreshModulesPath;
exports.getESLintInstance = getESLintInstance;
exports.getConfigPath = getConfigPath;
exports.getRelativePath = getRelativePath;
exports.getCLIEngineOptions = getCLIEngineOptions;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fsPlus = require('fs-plus');

var _fsPlus2 = _interopRequireDefault(_fsPlus);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _resolveEnv = require('resolve-env');

var _resolveEnv2 = _interopRequireDefault(_resolveEnv);

var _atomLinter = require('atom-linter');

var _consistentPath = require('consistent-path');

var _consistentPath2 = _interopRequireDefault(_consistentPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Cache = {
  ESLINT_LOCAL_PATH: _path2.default.normalize(_path2.default.join(__dirname, '..', 'node_modules', 'eslint')),
  NODE_PREFIX_PATH: null,
  LAST_MODULES_PATH: null

  /**
   * Takes a path and translates `~` to the user's home directory, and replaces
   * all environment variables with their value.
   * @param  {string} path The path to remove "strangeness" from
   * @return {string}      The cleaned path
   */
};const cleanPath = path => path ? (0, _resolveEnv2.default)(_fsPlus2.default.normalize(path)) : '';

function getNodePrefixPath() {
  if (Cache.NODE_PREFIX_PATH === null) {
    const npmCommand = process.platform === 'win32' ? 'npm.cmd' : 'npm';
    try {
      Cache.NODE_PREFIX_PATH = _child_process2.default.spawnSync(npmCommand, ['get', 'prefix'], {
        env: Object.assign(Object.assign({}, process.env), { PATH: (0, _consistentPath2.default)() })
      }).output[1].toString().trim();
    } catch (e) {
      const errMsg = 'Unable to execute `npm get prefix`. Please make sure ' + 'Atom is getting $PATH correctly.';
      throw new Error(errMsg);
    }
  }
  return Cache.NODE_PREFIX_PATH;
}

function isDirectory(dirPath) {
  let isDir;
  try {
    isDir = _fsPlus2.default.statSync(dirPath).isDirectory();
  } catch (e) {
    isDir = false;
  }
  return isDir;
}

function findESLintDirectory(modulesDir, config, projectPath) {
  let eslintDir = null;
  let locationType = null;
  if (config.useGlobalEslint) {
    locationType = 'global';
    const configGlobal = cleanPath(config.globalNodePath);
    const prefixPath = configGlobal || getNodePrefixPath();
    // NPM on Windows and Yarn on all platforms
    eslintDir = _path2.default.join(prefixPath, 'node_modules', 'eslint');
    if (!isDirectory(eslintDir)) {
      // NPM on platforms other than Windows
      eslintDir = _path2.default.join(prefixPath, 'lib', 'node_modules', 'eslint');
    }
  } else if (!config.advancedLocalNodeModules) {
    locationType = 'local project';
    eslintDir = _path2.default.join(modulesDir || '', 'eslint');
  } else if (_path2.default.isAbsolute(cleanPath(config.advancedLocalNodeModules))) {
    locationType = 'advanced specified';
    eslintDir = _path2.default.join(cleanPath(config.advancedLocalNodeModules), 'eslint');
  } else {
    locationType = 'advanced specified';
    eslintDir = _path2.default.join(projectPath || '', cleanPath(config.advancedLocalNodeModules), 'eslint');
  }
  if (isDirectory(eslintDir)) {
    return {
      path: eslintDir,
      type: locationType
    };
  } else if (config.useGlobalEslint) {
    throw new Error('ESLint not found, please ensure the global Node path is set correctly.');
  }
  return {
    path: Cache.ESLINT_LOCAL_PATH,
    type: 'bundled fallback'
  };
}

function getESLintFromDirectory(modulesDir, config, projectPath) {
  var _findESLintDirectory = findESLintDirectory(modulesDir, config, projectPath);

  const ESLintDirectory = _findESLintDirectory.path;

  try {
    // eslint-disable-next-line import/no-dynamic-require
    return require(ESLintDirectory);
  } catch (e) {
    if (config.useGlobalEslint && e.code === 'MODULE_NOT_FOUND') {
      throw new Error('ESLint not found, try restarting Atom to clear caches.');
    }
    // eslint-disable-next-line import/no-dynamic-require
    return require(Cache.ESLINT_LOCAL_PATH);
  }
}

function refreshModulesPath(modulesDir) {
  if (Cache.LAST_MODULES_PATH !== modulesDir) {
    Cache.LAST_MODULES_PATH = modulesDir;
    process.env.NODE_PATH = modulesDir || '';
    // eslint-disable-next-line no-underscore-dangle
    require('module').Module._initPaths();
  }
}

function getESLintInstance(fileDir, config, projectPath) {
  const modulesDir = _path2.default.dirname((0, _atomLinter.findCached)(fileDir, 'node_modules/eslint') || '');
  refreshModulesPath(modulesDir);
  return getESLintFromDirectory(modulesDir, config, projectPath);
}

function getConfigPath(fileDir) {
  const configFile = (0, _atomLinter.findCached)(fileDir, ['.eslintrc.js', '.eslintrc.yaml', '.eslintrc.yml', '.eslintrc.json', '.eslintrc', 'package.json']);
  if (configFile) {
    if (_path2.default.basename(configFile) === 'package.json') {
      // eslint-disable-next-line import/no-dynamic-require
      if (require(configFile).eslintConfig) {
        return configFile;
      }
      // If we are here, we found a package.json without an eslint config
      // in a dir without any other eslint config files
      // (because 'package.json' is last in the call to findCached)
      // So, keep looking from the parent directory
      return getConfigPath(_path2.default.resolve(_path2.default.dirname(configFile), '..'));
    }
    return configFile;
  }
  return null;
}

function getRelativePath(fileDir, filePath, config, projectPath) {
  const ignoreFile = config.disableEslintIgnore ? null : (0, _atomLinter.findCached)(fileDir, '.eslintignore');

  // If we can find an .eslintignore file, we can set cwd there
  // (because they are expected to be at the project root)
  if (ignoreFile) {
    const ignoreDir = _path2.default.dirname(ignoreFile);
    process.chdir(ignoreDir);
    return _path2.default.relative(ignoreDir, filePath);
  }
  // Otherwise, we'll set the cwd to the atom project root as long as that exists
  if (projectPath) {
    process.chdir(projectPath);
    return _path2.default.relative(projectPath, filePath);
  }
  // If all else fails, use the file location itself
  process.chdir(fileDir);
  return _path2.default.basename(filePath);
}

function getCLIEngineOptions(type, config, rules, filePath, fileDir, givenConfigPath) {
  const cliEngineConfig = {
    rules,
    ignore: !config.disableEslintIgnore,
    warnIgnored: false,
    fix: type === 'fix'
  };

  const ignoreFile = config.disableEslintIgnore ? null : (0, _atomLinter.findCached)(fileDir, '.eslintignore');
  if (ignoreFile) {
    cliEngineConfig.ignorePath = ignoreFile;
  }

  cliEngineConfig.rulePaths = config.eslintRulesDirs.map(path => {
    const rulesDir = cleanPath(path);
    if (!_path2.default.isAbsolute(rulesDir)) {
      return (0, _atomLinter.findCached)(fileDir, rulesDir);
    }
    return rulesDir;
  }).filter(path => path);

  if (givenConfigPath === null && config.eslintrcPath) {
    // If we didn't find a configuration use the fallback from the settings
    cliEngineConfig.configFile = cleanPath(config.eslintrcPath);
  }

  return cliEngineConfig;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndvcmtlci1oZWxwZXJzLmpzIl0sIm5hbWVzIjpbImdldE5vZGVQcmVmaXhQYXRoIiwiZmluZEVTTGludERpcmVjdG9yeSIsImdldEVTTGludEZyb21EaXJlY3RvcnkiLCJyZWZyZXNoTW9kdWxlc1BhdGgiLCJnZXRFU0xpbnRJbnN0YW5jZSIsImdldENvbmZpZ1BhdGgiLCJnZXRSZWxhdGl2ZVBhdGgiLCJnZXRDTElFbmdpbmVPcHRpb25zIiwiQ2FjaGUiLCJFU0xJTlRfTE9DQUxfUEFUSCIsIm5vcm1hbGl6ZSIsImpvaW4iLCJfX2Rpcm5hbWUiLCJOT0RFX1BSRUZJWF9QQVRIIiwiTEFTVF9NT0RVTEVTX1BBVEgiLCJjbGVhblBhdGgiLCJwYXRoIiwibnBtQ29tbWFuZCIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInNwYXduU3luYyIsImVudiIsIk9iamVjdCIsImFzc2lnbiIsIlBBVEgiLCJvdXRwdXQiLCJ0b1N0cmluZyIsInRyaW0iLCJlIiwiZXJyTXNnIiwiRXJyb3IiLCJpc0RpcmVjdG9yeSIsImRpclBhdGgiLCJpc0RpciIsInN0YXRTeW5jIiwibW9kdWxlc0RpciIsImNvbmZpZyIsInByb2plY3RQYXRoIiwiZXNsaW50RGlyIiwibG9jYXRpb25UeXBlIiwidXNlR2xvYmFsRXNsaW50IiwiY29uZmlnR2xvYmFsIiwiZ2xvYmFsTm9kZVBhdGgiLCJwcmVmaXhQYXRoIiwiYWR2YW5jZWRMb2NhbE5vZGVNb2R1bGVzIiwiaXNBYnNvbHV0ZSIsInR5cGUiLCJFU0xpbnREaXJlY3RvcnkiLCJyZXF1aXJlIiwiY29kZSIsIk5PREVfUEFUSCIsIk1vZHVsZSIsIl9pbml0UGF0aHMiLCJmaWxlRGlyIiwiZGlybmFtZSIsImNvbmZpZ0ZpbGUiLCJiYXNlbmFtZSIsImVzbGludENvbmZpZyIsInJlc29sdmUiLCJmaWxlUGF0aCIsImlnbm9yZUZpbGUiLCJkaXNhYmxlRXNsaW50SWdub3JlIiwiaWdub3JlRGlyIiwiY2hkaXIiLCJyZWxhdGl2ZSIsInJ1bGVzIiwiZ2l2ZW5Db25maWdQYXRoIiwiY2xpRW5naW5lQ29uZmlnIiwiaWdub3JlIiwid2Fybklnbm9yZWQiLCJmaXgiLCJpZ25vcmVQYXRoIiwicnVsZVBhdGhzIiwiZXNsaW50UnVsZXNEaXJzIiwibWFwIiwicnVsZXNEaXIiLCJmaWx0ZXIiLCJlc2xpbnRyY1BhdGgiXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7UUF1QmdCQSxpQixHQUFBQSxpQjtRQTJCQUMsbUIsR0FBQUEsbUI7UUFxQ0FDLHNCLEdBQUFBLHNCO1FBY0FDLGtCLEdBQUFBLGtCO1FBU0FDLGlCLEdBQUFBLGlCO1FBTUFDLGEsR0FBQUEsYTtRQXNCQUMsZSxHQUFBQSxlO1FBb0JBQyxtQixHQUFBQSxtQjs7QUE1SmhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLE1BQU1DLFFBQVE7QUFDWkMscUJBQW1CLGVBQUtDLFNBQUwsQ0FBZSxlQUFLQyxJQUFMLENBQVVDLFNBQVYsRUFBcUIsSUFBckIsRUFBMkIsY0FBM0IsRUFBMkMsUUFBM0MsQ0FBZixDQURQO0FBRVpDLG9CQUFrQixJQUZOO0FBR1pDLHFCQUFtQjs7QUFHckI7Ozs7OztBQU5jLENBQWQsQ0FZQSxNQUFNQyxZQUFZQyxRQUFTQSxPQUFPLDBCQUFXLGlCQUFHTixTQUFILENBQWFNLElBQWIsQ0FBWCxDQUFQLEdBQXdDLEVBQW5FOztBQUVPLFNBQVNoQixpQkFBVCxHQUE2QjtBQUNsQyxNQUFJUSxNQUFNSyxnQkFBTixLQUEyQixJQUEvQixFQUFxQztBQUNuQyxVQUFNSSxhQUFhQyxRQUFRQyxRQUFSLEtBQXFCLE9BQXJCLEdBQStCLFNBQS9CLEdBQTJDLEtBQTlEO0FBQ0EsUUFBSTtBQUNGWCxZQUFNSyxnQkFBTixHQUNFLHdCQUFhTyxTQUFiLENBQXVCSCxVQUF2QixFQUFtQyxDQUFDLEtBQUQsRUFBUSxRQUFSLENBQW5DLEVBQXNEO0FBQ3BESSxhQUFLQyxPQUFPQyxNQUFQLENBQWNELE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCTCxRQUFRRyxHQUExQixDQUFkLEVBQThDLEVBQUVHLE1BQU0sK0JBQVIsRUFBOUM7QUFEK0MsT0FBdEQsRUFFR0MsTUFGSCxDQUVVLENBRlYsRUFFYUMsUUFGYixHQUV3QkMsSUFGeEIsRUFERjtBQUlELEtBTEQsQ0FLRSxPQUFPQyxDQUFQLEVBQVU7QUFDVixZQUFNQyxTQUFTLDBEQUNiLGtDQURGO0FBRUEsWUFBTSxJQUFJQyxLQUFKLENBQVVELE1BQVYsQ0FBTjtBQUNEO0FBQ0Y7QUFDRCxTQUFPckIsTUFBTUssZ0JBQWI7QUFDRDs7QUFFRCxTQUFTa0IsV0FBVCxDQUFxQkMsT0FBckIsRUFBOEI7QUFDNUIsTUFBSUMsS0FBSjtBQUNBLE1BQUk7QUFDRkEsWUFBUSxpQkFBR0MsUUFBSCxDQUFZRixPQUFaLEVBQXFCRCxXQUFyQixFQUFSO0FBQ0QsR0FGRCxDQUVFLE9BQU9ILENBQVAsRUFBVTtBQUNWSyxZQUFRLEtBQVI7QUFDRDtBQUNELFNBQU9BLEtBQVA7QUFDRDs7QUFFTSxTQUFTaEMsbUJBQVQsQ0FBNkJrQyxVQUE3QixFQUF5Q0MsTUFBekMsRUFBaURDLFdBQWpELEVBQThEO0FBQ25FLE1BQUlDLFlBQVksSUFBaEI7QUFDQSxNQUFJQyxlQUFlLElBQW5CO0FBQ0EsTUFBSUgsT0FBT0ksZUFBWCxFQUE0QjtBQUMxQkQsbUJBQWUsUUFBZjtBQUNBLFVBQU1FLGVBQWUxQixVQUFVcUIsT0FBT00sY0FBakIsQ0FBckI7QUFDQSxVQUFNQyxhQUFhRixnQkFBZ0J6QyxtQkFBbkM7QUFDQTtBQUNBc0MsZ0JBQVksZUFBSzNCLElBQUwsQ0FBVWdDLFVBQVYsRUFBc0IsY0FBdEIsRUFBc0MsUUFBdEMsQ0FBWjtBQUNBLFFBQUksQ0FBQ1osWUFBWU8sU0FBWixDQUFMLEVBQTZCO0FBQzNCO0FBQ0FBLGtCQUFZLGVBQUszQixJQUFMLENBQVVnQyxVQUFWLEVBQXNCLEtBQXRCLEVBQTZCLGNBQTdCLEVBQTZDLFFBQTdDLENBQVo7QUFDRDtBQUNGLEdBVkQsTUFVTyxJQUFJLENBQUNQLE9BQU9RLHdCQUFaLEVBQXNDO0FBQzNDTCxtQkFBZSxlQUFmO0FBQ0FELGdCQUFZLGVBQUszQixJQUFMLENBQVV3QixjQUFjLEVBQXhCLEVBQTRCLFFBQTVCLENBQVo7QUFDRCxHQUhNLE1BR0EsSUFBSSxlQUFLVSxVQUFMLENBQWdCOUIsVUFBVXFCLE9BQU9RLHdCQUFqQixDQUFoQixDQUFKLEVBQWlFO0FBQ3RFTCxtQkFBZSxvQkFBZjtBQUNBRCxnQkFBWSxlQUFLM0IsSUFBTCxDQUFVSSxVQUFVcUIsT0FBT1Esd0JBQWpCLENBQVYsRUFBc0QsUUFBdEQsQ0FBWjtBQUNELEdBSE0sTUFHQTtBQUNMTCxtQkFBZSxvQkFBZjtBQUNBRCxnQkFBWSxlQUFLM0IsSUFBTCxDQUFVMEIsZUFBZSxFQUF6QixFQUE2QnRCLFVBQVVxQixPQUFPUSx3QkFBakIsQ0FBN0IsRUFBeUUsUUFBekUsQ0FBWjtBQUNEO0FBQ0QsTUFBSWIsWUFBWU8sU0FBWixDQUFKLEVBQTRCO0FBQzFCLFdBQU87QUFDTHRCLFlBQU1zQixTQUREO0FBRUxRLFlBQU1QO0FBRkQsS0FBUDtBQUlELEdBTEQsTUFLTyxJQUFJSCxPQUFPSSxlQUFYLEVBQTRCO0FBQ2pDLFVBQU0sSUFBSVYsS0FBSixDQUFVLHdFQUFWLENBQU47QUFDRDtBQUNELFNBQU87QUFDTGQsVUFBTVIsTUFBTUMsaUJBRFA7QUFFTHFDLFVBQU07QUFGRCxHQUFQO0FBSUQ7O0FBRU0sU0FBUzVDLHNCQUFULENBQWdDaUMsVUFBaEMsRUFBNENDLE1BQTVDLEVBQW9EQyxXQUFwRCxFQUFpRTtBQUFBLDZCQUNwQ3BDLG9CQUFvQmtDLFVBQXBCLEVBQWdDQyxNQUFoQyxFQUF3Q0MsV0FBeEMsQ0FEb0M7O0FBQUEsUUFDeERVLGVBRHdELHdCQUM5RC9CLElBRDhEOztBQUV0RSxNQUFJO0FBQ0Y7QUFDQSxXQUFPZ0MsUUFBUUQsZUFBUixDQUFQO0FBQ0QsR0FIRCxDQUdFLE9BQU9uQixDQUFQLEVBQVU7QUFDVixRQUFJUSxPQUFPSSxlQUFQLElBQTBCWixFQUFFcUIsSUFBRixLQUFXLGtCQUF6QyxFQUE2RDtBQUMzRCxZQUFNLElBQUluQixLQUFKLENBQVUsd0RBQVYsQ0FBTjtBQUNEO0FBQ0Q7QUFDQSxXQUFPa0IsUUFBUXhDLE1BQU1DLGlCQUFkLENBQVA7QUFDRDtBQUNGOztBQUVNLFNBQVNOLGtCQUFULENBQTRCZ0MsVUFBNUIsRUFBd0M7QUFDN0MsTUFBSTNCLE1BQU1NLGlCQUFOLEtBQTRCcUIsVUFBaEMsRUFBNEM7QUFDMUMzQixVQUFNTSxpQkFBTixHQUEwQnFCLFVBQTFCO0FBQ0FqQixZQUFRRyxHQUFSLENBQVk2QixTQUFaLEdBQXdCZixjQUFjLEVBQXRDO0FBQ0E7QUFDQWEsWUFBUSxRQUFSLEVBQWtCRyxNQUFsQixDQUF5QkMsVUFBekI7QUFDRDtBQUNGOztBQUVNLFNBQVNoRCxpQkFBVCxDQUEyQmlELE9BQTNCLEVBQW9DakIsTUFBcEMsRUFBNENDLFdBQTVDLEVBQXlEO0FBQzlELFFBQU1GLGFBQWEsZUFBS21CLE9BQUwsQ0FBYSw0QkFBV0QsT0FBWCxFQUFvQixxQkFBcEIsS0FBOEMsRUFBM0QsQ0FBbkI7QUFDQWxELHFCQUFtQmdDLFVBQW5CO0FBQ0EsU0FBT2pDLHVCQUF1QmlDLFVBQXZCLEVBQW1DQyxNQUFuQyxFQUEyQ0MsV0FBM0MsQ0FBUDtBQUNEOztBQUVNLFNBQVNoQyxhQUFULENBQXVCZ0QsT0FBdkIsRUFBZ0M7QUFDckMsUUFBTUUsYUFDSiw0QkFBV0YsT0FBWCxFQUFvQixDQUNsQixjQURrQixFQUNGLGdCQURFLEVBQ2dCLGVBRGhCLEVBQ2lDLGdCQURqQyxFQUNtRCxXQURuRCxFQUNnRSxjQURoRSxDQUFwQixDQURGO0FBSUEsTUFBSUUsVUFBSixFQUFnQjtBQUNkLFFBQUksZUFBS0MsUUFBTCxDQUFjRCxVQUFkLE1BQThCLGNBQWxDLEVBQWtEO0FBQ2hEO0FBQ0EsVUFBSVAsUUFBUU8sVUFBUixFQUFvQkUsWUFBeEIsRUFBc0M7QUFDcEMsZUFBT0YsVUFBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFPbEQsY0FBYyxlQUFLcUQsT0FBTCxDQUFhLGVBQUtKLE9BQUwsQ0FBYUMsVUFBYixDQUFiLEVBQXVDLElBQXZDLENBQWQsQ0FBUDtBQUNEO0FBQ0QsV0FBT0EsVUFBUDtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRU0sU0FBU2pELGVBQVQsQ0FBeUIrQyxPQUF6QixFQUFrQ00sUUFBbEMsRUFBNEN2QixNQUE1QyxFQUFvREMsV0FBcEQsRUFBaUU7QUFDdEUsUUFBTXVCLGFBQWF4QixPQUFPeUIsbUJBQVAsR0FBNkIsSUFBN0IsR0FBb0MsNEJBQVdSLE9BQVgsRUFBb0IsZUFBcEIsQ0FBdkQ7O0FBRUE7QUFDQTtBQUNBLE1BQUlPLFVBQUosRUFBZ0I7QUFDZCxVQUFNRSxZQUFZLGVBQUtSLE9BQUwsQ0FBYU0sVUFBYixDQUFsQjtBQUNBMUMsWUFBUTZDLEtBQVIsQ0FBY0QsU0FBZDtBQUNBLFdBQU8sZUFBS0UsUUFBTCxDQUFjRixTQUFkLEVBQXlCSCxRQUF6QixDQUFQO0FBQ0Q7QUFDRDtBQUNBLE1BQUl0QixXQUFKLEVBQWlCO0FBQ2ZuQixZQUFRNkMsS0FBUixDQUFjMUIsV0FBZDtBQUNBLFdBQU8sZUFBSzJCLFFBQUwsQ0FBYzNCLFdBQWQsRUFBMkJzQixRQUEzQixDQUFQO0FBQ0Q7QUFDRDtBQUNBekMsVUFBUTZDLEtBQVIsQ0FBY1YsT0FBZDtBQUNBLFNBQU8sZUFBS0csUUFBTCxDQUFjRyxRQUFkLENBQVA7QUFDRDs7QUFFTSxTQUFTcEQsbUJBQVQsQ0FBNkJ1QyxJQUE3QixFQUFtQ1YsTUFBbkMsRUFBMkM2QixLQUEzQyxFQUFrRE4sUUFBbEQsRUFBNEROLE9BQTVELEVBQXFFYSxlQUFyRSxFQUFzRjtBQUMzRixRQUFNQyxrQkFBa0I7QUFDdEJGLFNBRHNCO0FBRXRCRyxZQUFRLENBQUNoQyxPQUFPeUIsbUJBRk07QUFHdEJRLGlCQUFhLEtBSFM7QUFJdEJDLFNBQUt4QixTQUFTO0FBSlEsR0FBeEI7O0FBT0EsUUFBTWMsYUFBYXhCLE9BQU95QixtQkFBUCxHQUE2QixJQUE3QixHQUFvQyw0QkFBV1IsT0FBWCxFQUFvQixlQUFwQixDQUF2RDtBQUNBLE1BQUlPLFVBQUosRUFBZ0I7QUFDZE8sb0JBQWdCSSxVQUFoQixHQUE2QlgsVUFBN0I7QUFDRDs7QUFFRE8sa0JBQWdCSyxTQUFoQixHQUE0QnBDLE9BQU9xQyxlQUFQLENBQXVCQyxHQUF2QixDQUE0QjFELElBQUQsSUFBVTtBQUMvRCxVQUFNMkQsV0FBVzVELFVBQVVDLElBQVYsQ0FBakI7QUFDQSxRQUFJLENBQUMsZUFBSzZCLFVBQUwsQ0FBZ0I4QixRQUFoQixDQUFMLEVBQWdDO0FBQzlCLGFBQU8sNEJBQVd0QixPQUFYLEVBQW9Cc0IsUUFBcEIsQ0FBUDtBQUNEO0FBQ0QsV0FBT0EsUUFBUDtBQUNELEdBTjJCLEVBTXpCQyxNQU55QixDQU1sQjVELFFBQVFBLElBTlUsQ0FBNUI7O0FBUUEsTUFBSWtELG9CQUFvQixJQUFwQixJQUE0QjlCLE9BQU95QyxZQUF2QyxFQUFxRDtBQUNuRDtBQUNBVixvQkFBZ0JaLFVBQWhCLEdBQTZCeEMsVUFBVXFCLE9BQU95QyxZQUFqQixDQUE3QjtBQUNEOztBQUVELFNBQU9WLGVBQVA7QUFDRCIsImZpbGUiOiJ3b3JrZXItaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvZXZhbmhlbmRyaXgxLy5hdG9tL3BhY2thZ2VzL2xpbnRlci1lc2xpbnQiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJ1xuXG5pbXBvcnQgUGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzLXBsdXMnXG5pbXBvcnQgQ2hpbGRQcm9jZXNzIGZyb20gJ2NoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgcmVzb2x2ZUVudiBmcm9tICdyZXNvbHZlLWVudidcbmltcG9ydCB7IGZpbmRDYWNoZWQgfSBmcm9tICdhdG9tLWxpbnRlcidcbmltcG9ydCBnZXRQYXRoIGZyb20gJ2NvbnNpc3RlbnQtcGF0aCdcblxuY29uc3QgQ2FjaGUgPSB7XG4gIEVTTElOVF9MT0NBTF9QQVRIOiBQYXRoLm5vcm1hbGl6ZShQYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnbm9kZV9tb2R1bGVzJywgJ2VzbGludCcpKSxcbiAgTk9ERV9QUkVGSVhfUEFUSDogbnVsbCxcbiAgTEFTVF9NT0RVTEVTX1BBVEg6IG51bGxcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHBhdGggYW5kIHRyYW5zbGF0ZXMgYH5gIHRvIHRoZSB1c2VyJ3MgaG9tZSBkaXJlY3RvcnksIGFuZCByZXBsYWNlc1xuICogYWxsIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aXRoIHRoZWlyIHZhbHVlLlxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHJlbW92ZSBcInN0cmFuZ2VuZXNzXCIgZnJvbVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgIFRoZSBjbGVhbmVkIHBhdGhcbiAqL1xuY29uc3QgY2xlYW5QYXRoID0gcGF0aCA9PiAocGF0aCA/IHJlc29sdmVFbnYoZnMubm9ybWFsaXplKHBhdGgpKSA6ICcnKVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVByZWZpeFBhdGgoKSB7XG4gIGlmIChDYWNoZS5OT0RFX1BSRUZJWF9QQVRIID09PSBudWxsKSB7XG4gICAgY29uc3QgbnBtQ29tbWFuZCA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnbnBtLmNtZCcgOiAnbnBtJ1xuICAgIHRyeSB7XG4gICAgICBDYWNoZS5OT0RFX1BSRUZJWF9QQVRIID1cbiAgICAgICAgQ2hpbGRQcm9jZXNzLnNwYXduU3luYyhucG1Db21tYW5kLCBbJ2dldCcsICdwcmVmaXgnXSwge1xuICAgICAgICAgIGVudjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudiksIHsgUEFUSDogZ2V0UGF0aCgpIH0pXG4gICAgICAgIH0pLm91dHB1dFsxXS50b1N0cmluZygpLnRyaW0oKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IGVyck1zZyA9ICdVbmFibGUgdG8gZXhlY3V0ZSBgbnBtIGdldCBwcmVmaXhgLiBQbGVhc2UgbWFrZSBzdXJlICcgK1xuICAgICAgICAnQXRvbSBpcyBnZXR0aW5nICRQQVRIIGNvcnJlY3RseS4nXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gQ2FjaGUuTk9ERV9QUkVGSVhfUEFUSFxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdG9yeShkaXJQYXRoKSB7XG4gIGxldCBpc0RpclxuICB0cnkge1xuICAgIGlzRGlyID0gZnMuc3RhdFN5bmMoZGlyUGF0aCkuaXNEaXJlY3RvcnkoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaXNEaXIgPSBmYWxzZVxuICB9XG4gIHJldHVybiBpc0RpclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEVTTGludERpcmVjdG9yeShtb2R1bGVzRGlyLCBjb25maWcsIHByb2plY3RQYXRoKSB7XG4gIGxldCBlc2xpbnREaXIgPSBudWxsXG4gIGxldCBsb2NhdGlvblR5cGUgPSBudWxsXG4gIGlmIChjb25maWcudXNlR2xvYmFsRXNsaW50KSB7XG4gICAgbG9jYXRpb25UeXBlID0gJ2dsb2JhbCdcbiAgICBjb25zdCBjb25maWdHbG9iYWwgPSBjbGVhblBhdGgoY29uZmlnLmdsb2JhbE5vZGVQYXRoKVxuICAgIGNvbnN0IHByZWZpeFBhdGggPSBjb25maWdHbG9iYWwgfHwgZ2V0Tm9kZVByZWZpeFBhdGgoKVxuICAgIC8vIE5QTSBvbiBXaW5kb3dzIGFuZCBZYXJuIG9uIGFsbCBwbGF0Zm9ybXNcbiAgICBlc2xpbnREaXIgPSBQYXRoLmpvaW4ocHJlZml4UGF0aCwgJ25vZGVfbW9kdWxlcycsICdlc2xpbnQnKVxuICAgIGlmICghaXNEaXJlY3RvcnkoZXNsaW50RGlyKSkge1xuICAgICAgLy8gTlBNIG9uIHBsYXRmb3JtcyBvdGhlciB0aGFuIFdpbmRvd3NcbiAgICAgIGVzbGludERpciA9IFBhdGguam9pbihwcmVmaXhQYXRoLCAnbGliJywgJ25vZGVfbW9kdWxlcycsICdlc2xpbnQnKVxuICAgIH1cbiAgfSBlbHNlIGlmICghY29uZmlnLmFkdmFuY2VkTG9jYWxOb2RlTW9kdWxlcykge1xuICAgIGxvY2F0aW9uVHlwZSA9ICdsb2NhbCBwcm9qZWN0J1xuICAgIGVzbGludERpciA9IFBhdGguam9pbihtb2R1bGVzRGlyIHx8ICcnLCAnZXNsaW50JylcbiAgfSBlbHNlIGlmIChQYXRoLmlzQWJzb2x1dGUoY2xlYW5QYXRoKGNvbmZpZy5hZHZhbmNlZExvY2FsTm9kZU1vZHVsZXMpKSkge1xuICAgIGxvY2F0aW9uVHlwZSA9ICdhZHZhbmNlZCBzcGVjaWZpZWQnXG4gICAgZXNsaW50RGlyID0gUGF0aC5qb2luKGNsZWFuUGF0aChjb25maWcuYWR2YW5jZWRMb2NhbE5vZGVNb2R1bGVzKSwgJ2VzbGludCcpXG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb25UeXBlID0gJ2FkdmFuY2VkIHNwZWNpZmllZCdcbiAgICBlc2xpbnREaXIgPSBQYXRoLmpvaW4ocHJvamVjdFBhdGggfHwgJycsIGNsZWFuUGF0aChjb25maWcuYWR2YW5jZWRMb2NhbE5vZGVNb2R1bGVzKSwgJ2VzbGludCcpXG4gIH1cbiAgaWYgKGlzRGlyZWN0b3J5KGVzbGludERpcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogZXNsaW50RGlyLFxuICAgICAgdHlwZTogbG9jYXRpb25UeXBlLFxuICAgIH1cbiAgfSBlbHNlIGlmIChjb25maWcudXNlR2xvYmFsRXNsaW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFU0xpbnQgbm90IGZvdW5kLCBwbGVhc2UgZW5zdXJlIHRoZSBnbG9iYWwgTm9kZSBwYXRoIGlzIHNldCBjb3JyZWN0bHkuJylcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGg6IENhY2hlLkVTTElOVF9MT0NBTF9QQVRILFxuICAgIHR5cGU6ICdidW5kbGVkIGZhbGxiYWNrJyxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RVNMaW50RnJvbURpcmVjdG9yeShtb2R1bGVzRGlyLCBjb25maWcsIHByb2plY3RQYXRoKSB7XG4gIGNvbnN0IHsgcGF0aDogRVNMaW50RGlyZWN0b3J5IH0gPSBmaW5kRVNMaW50RGlyZWN0b3J5KG1vZHVsZXNEaXIsIGNvbmZpZywgcHJvamVjdFBhdGgpXG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICByZXR1cm4gcmVxdWlyZShFU0xpbnREaXJlY3RvcnkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoY29uZmlnLnVzZUdsb2JhbEVzbGludCAmJiBlLmNvZGUgPT09ICdNT0RVTEVfTk9UX0ZPVU5EJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFU0xpbnQgbm90IGZvdW5kLCB0cnkgcmVzdGFydGluZyBBdG9tIHRvIGNsZWFyIGNhY2hlcy4nKVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWR5bmFtaWMtcmVxdWlyZVxuICAgIHJldHVybiByZXF1aXJlKENhY2hlLkVTTElOVF9MT0NBTF9QQVRIKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZyZXNoTW9kdWxlc1BhdGgobW9kdWxlc0Rpcikge1xuICBpZiAoQ2FjaGUuTEFTVF9NT0RVTEVTX1BBVEggIT09IG1vZHVsZXNEaXIpIHtcbiAgICBDYWNoZS5MQVNUX01PRFVMRVNfUEFUSCA9IG1vZHVsZXNEaXJcbiAgICBwcm9jZXNzLmVudi5OT0RFX1BBVEggPSBtb2R1bGVzRGlyIHx8ICcnXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgcmVxdWlyZSgnbW9kdWxlJykuTW9kdWxlLl9pbml0UGF0aHMoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFU0xpbnRJbnN0YW5jZShmaWxlRGlyLCBjb25maWcsIHByb2plY3RQYXRoKSB7XG4gIGNvbnN0IG1vZHVsZXNEaXIgPSBQYXRoLmRpcm5hbWUoZmluZENhY2hlZChmaWxlRGlyLCAnbm9kZV9tb2R1bGVzL2VzbGludCcpIHx8ICcnKVxuICByZWZyZXNoTW9kdWxlc1BhdGgobW9kdWxlc0RpcilcbiAgcmV0dXJuIGdldEVTTGludEZyb21EaXJlY3RvcnkobW9kdWxlc0RpciwgY29uZmlnLCBwcm9qZWN0UGF0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpZ1BhdGgoZmlsZURpcikge1xuICBjb25zdCBjb25maWdGaWxlID1cbiAgICBmaW5kQ2FjaGVkKGZpbGVEaXIsIFtcbiAgICAgICcuZXNsaW50cmMuanMnLCAnLmVzbGludHJjLnlhbWwnLCAnLmVzbGludHJjLnltbCcsICcuZXNsaW50cmMuanNvbicsICcuZXNsaW50cmMnLCAncGFja2FnZS5qc29uJ1xuICAgIF0pXG4gIGlmIChjb25maWdGaWxlKSB7XG4gICAgaWYgKFBhdGguYmFzZW5hbWUoY29uZmlnRmlsZSkgPT09ICdwYWNrYWdlLmpzb24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWR5bmFtaWMtcmVxdWlyZVxuICAgICAgaWYgKHJlcXVpcmUoY29uZmlnRmlsZSkuZXNsaW50Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBjb25maWdGaWxlXG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBhcmUgaGVyZSwgd2UgZm91bmQgYSBwYWNrYWdlLmpzb24gd2l0aG91dCBhbiBlc2xpbnQgY29uZmlnXG4gICAgICAvLyBpbiBhIGRpciB3aXRob3V0IGFueSBvdGhlciBlc2xpbnQgY29uZmlnIGZpbGVzXG4gICAgICAvLyAoYmVjYXVzZSAncGFja2FnZS5qc29uJyBpcyBsYXN0IGluIHRoZSBjYWxsIHRvIGZpbmRDYWNoZWQpXG4gICAgICAvLyBTbywga2VlcCBsb29raW5nIGZyb20gdGhlIHBhcmVudCBkaXJlY3RvcnlcbiAgICAgIHJldHVybiBnZXRDb25maWdQYXRoKFBhdGgucmVzb2x2ZShQYXRoLmRpcm5hbWUoY29uZmlnRmlsZSksICcuLicpKVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnRmlsZVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBhdGgoZmlsZURpciwgZmlsZVBhdGgsIGNvbmZpZywgcHJvamVjdFBhdGgpIHtcbiAgY29uc3QgaWdub3JlRmlsZSA9IGNvbmZpZy5kaXNhYmxlRXNsaW50SWdub3JlID8gbnVsbCA6IGZpbmRDYWNoZWQoZmlsZURpciwgJy5lc2xpbnRpZ25vcmUnKVxuXG4gIC8vIElmIHdlIGNhbiBmaW5kIGFuIC5lc2xpbnRpZ25vcmUgZmlsZSwgd2UgY2FuIHNldCBjd2QgdGhlcmVcbiAgLy8gKGJlY2F1c2UgdGhleSBhcmUgZXhwZWN0ZWQgdG8gYmUgYXQgdGhlIHByb2plY3Qgcm9vdClcbiAgaWYgKGlnbm9yZUZpbGUpIHtcbiAgICBjb25zdCBpZ25vcmVEaXIgPSBQYXRoLmRpcm5hbWUoaWdub3JlRmlsZSlcbiAgICBwcm9jZXNzLmNoZGlyKGlnbm9yZURpcilcbiAgICByZXR1cm4gUGF0aC5yZWxhdGl2ZShpZ25vcmVEaXIsIGZpbGVQYXRoKVxuICB9XG4gIC8vIE90aGVyd2lzZSwgd2UnbGwgc2V0IHRoZSBjd2QgdG8gdGhlIGF0b20gcHJvamVjdCByb290IGFzIGxvbmcgYXMgdGhhdCBleGlzdHNcbiAgaWYgKHByb2plY3RQYXRoKSB7XG4gICAgcHJvY2Vzcy5jaGRpcihwcm9qZWN0UGF0aClcbiAgICByZXR1cm4gUGF0aC5yZWxhdGl2ZShwcm9qZWN0UGF0aCwgZmlsZVBhdGgpXG4gIH1cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSB0aGUgZmlsZSBsb2NhdGlvbiBpdHNlbGZcbiAgcHJvY2Vzcy5jaGRpcihmaWxlRGlyKVxuICByZXR1cm4gUGF0aC5iYXNlbmFtZShmaWxlUGF0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENMSUVuZ2luZU9wdGlvbnModHlwZSwgY29uZmlnLCBydWxlcywgZmlsZVBhdGgsIGZpbGVEaXIsIGdpdmVuQ29uZmlnUGF0aCkge1xuICBjb25zdCBjbGlFbmdpbmVDb25maWcgPSB7XG4gICAgcnVsZXMsXG4gICAgaWdub3JlOiAhY29uZmlnLmRpc2FibGVFc2xpbnRJZ25vcmUsXG4gICAgd2Fybklnbm9yZWQ6IGZhbHNlLFxuICAgIGZpeDogdHlwZSA9PT0gJ2ZpeCdcbiAgfVxuXG4gIGNvbnN0IGlnbm9yZUZpbGUgPSBjb25maWcuZGlzYWJsZUVzbGludElnbm9yZSA/IG51bGwgOiBmaW5kQ2FjaGVkKGZpbGVEaXIsICcuZXNsaW50aWdub3JlJylcbiAgaWYgKGlnbm9yZUZpbGUpIHtcbiAgICBjbGlFbmdpbmVDb25maWcuaWdub3JlUGF0aCA9IGlnbm9yZUZpbGVcbiAgfVxuXG4gIGNsaUVuZ2luZUNvbmZpZy5ydWxlUGF0aHMgPSBjb25maWcuZXNsaW50UnVsZXNEaXJzLm1hcCgocGF0aCkgPT4ge1xuICAgIGNvbnN0IHJ1bGVzRGlyID0gY2xlYW5QYXRoKHBhdGgpXG4gICAgaWYgKCFQYXRoLmlzQWJzb2x1dGUocnVsZXNEaXIpKSB7XG4gICAgICByZXR1cm4gZmluZENhY2hlZChmaWxlRGlyLCBydWxlc0RpcilcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVzRGlyXG4gIH0pLmZpbHRlcihwYXRoID0+IHBhdGgpXG5cbiAgaWYgKGdpdmVuQ29uZmlnUGF0aCA9PT0gbnVsbCAmJiBjb25maWcuZXNsaW50cmNQYXRoKSB7XG4gICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYSBjb25maWd1cmF0aW9uIHVzZSB0aGUgZmFsbGJhY2sgZnJvbSB0aGUgc2V0dGluZ3NcbiAgICBjbGlFbmdpbmVDb25maWcuY29uZmlnRmlsZSA9IGNsZWFuUGF0aChjb25maWcuZXNsaW50cmNQYXRoKVxuICB9XG5cbiAgcmV0dXJuIGNsaUVuZ2luZUNvbmZpZ1xufVxuIl19